// reporter/custom-ts-reporter.js
// CommonJS version — drop in and use directly (no tsc required).

const fs = require('fs');
const path = require('path');

let opener = null;
try {
  opener = require('open');
} catch (e) {
  opener = null;
}

const HISTORY_FILENAME = 'history.json';
const LAST_RESULTS_FILENAME = 'last-results.json';
const RESULTS_FILENAME = 'results.json';
const REPORT_FILENAME = 'custom-report.html';

class CustomTsReporter {
  constructor(options = {}) {
    this.options = options || {};
    this.outDir = path.resolve(process.cwd(), this.options.outputDir || 'playwright-report');
    if (!fs.existsSync(this.outDir)) fs.mkdirSync(this.outDir, { recursive: true });
    this.results = [];
    this.startTime = null;
    this.config = undefined;
  }

  onBegin(config, suite) {
    this.startTime = new Date();
    this.config = config;
    const resultsPath = path.join(this.outDir, RESULTS_FILENAME);
    const lastPath = path.join(this.outDir, LAST_RESULTS_FILENAME);
    try {
      if (fs.existsSync(resultsPath)) {
        fs.copyFileSync(resultsPath, lastPath);
      }
    } catch (e) {
      // ignore
    }
  }

  async onTestEnd(test, result) {
    const fullTitle = this._getFullTitle(test);
    const id = this._makeId(test, fullTitle);

    const attachments = (result.attachments || []).map((a) => {
      const attachment = { name: a.name, contentType: a.contentType || null, path: null, dataUri: null };
      try {
        if (a.path && fs.existsSync(a.path)) {
          const raw = fs.readFileSync(a.path);
          const mime = a.contentType || this._guessMime(a.name || '');
          if (mime && mime.startsWith('image/')) {
            attachment.dataUri = `data:${mime};base64,${raw.toString('base64')}`;
          } else {
            const outName = `${Date.now()}-${path.basename(a.path)}`;
            const outPath = path.join(this.outDir, outName);
            fs.writeFileSync(outPath, raw);
            attachment.path = outName;
          }
        }
      } catch (e) {
        // ignore
      }
      return attachment;
    });

    const ct = {
      id,
      title: test.title,
      fullTitle,
      file: (test.location && test.location.file) || test._file || undefined,
      location: test.location || null,
      status: result.status,
      durationMs: result.duration,
      error: result.error ? (result.error.message || String(result.error)) : null,
      attachments,
    };

    this.results.push(ct);
  }

  async onEnd() {
    const endTime = new Date();
    const summary = {
      startTime: this.startTime ? this.startTime.toISOString() : new Date().toISOString(),
      endTime: endTime.toISOString(),
      durationMs: this.startTime ? endTime.getTime() - this.startTime.getTime() : 0,
      total: this.results.length,
      passed: this.results.filter(r => r.status === 'passed').length,
      failed: this.results.filter(r => r.status === 'failed').length,
      skipped: this.results.filter(r => r.status === 'skipped').length,
    };

    const historyPath = path.join(this.outDir, HISTORY_FILENAME);
    const lastResultsPath = path.join(this.outDir, LAST_RESULTS_FILENAME);
    let history = {};
    try {
      if (fs.existsSync(historyPath)) {
        history = JSON.parse(fs.readFileSync(historyPath, 'utf8'));
      }
    } catch (e) { history = {}; }

    let lastResults = null;
    try {
      if (fs.existsSync(lastResultsPath)) {
        lastResults = JSON.parse(fs.readFileSync(lastResultsPath, 'utf8'));
      }
    } catch (e) { lastResults = null; }

    for (const t of this.results) {
      const prev = history[t.id] || 0;
      if (t.status === 'failed') history[t.id] = prev + 1;
      else history[t.id] = prev;
    }
    try { fs.writeFileSync(historyPath, JSON.stringify(history, null, 2), 'utf8'); } catch (e) {}

    const fullReport = { summary, tests: this.results, meta: { commit: process.env.GIT_COMMIT || process.env.GITHUB_SHA || undefined, ci: !!process.env.CI } };
    try { fs.writeFileSync(path.join(this.outDir, RESULTS_FILENAME), JSON.stringify(fullReport, null, 2), 'utf8'); } catch (e) {}

    try {
      const html = this._renderHtml(fullReport, history, lastResults);
      const outPath = path.join(this.outDir, REPORT_FILENAME);
      fs.writeFileSync(outPath, html, 'utf8');
      console.log(`\nCustom TypeScript report generated: ${outPath}`);

      const openRequested = process.env.OPEN_REPORT === '1' || process.env.OPEN_REPORT === 'true';
      const inCi = !!process.env.CI;
      if ((openRequested || !inCi) && opener) {
        try {
          if (process.env.OPEN_REPORT === '0' || process.env.OPEN_REPORT === 'false') {
            // don't open
          } else if (openRequested || !inCi) {
            await opener(outPath);
          }
        } catch (e) {
          console.error('Failed to open report automatically:', e);
        }
      } else if ((openRequested || !inCi) && !opener) {
        console.log('Note: report auto-open requested but `open` package is not installed. Run `npm i -D open` to enable.');
      }

    } catch (e) {
      console.error('Failed to write HTML report', e);
    }
  }

  _getFullTitle(test) {
    if (!test) return '';
    const names = [];
    let p = test.parent;
    while (p && p.title) {
      names.unshift(p.title);
      p = p.parent;
    }
    return names.concat([test.title]).join(' > ');
  }

  _makeId(test, fullTitle) {
    const file = (test.location && test.location.file) || test._file || 'unknown-file';
    return `${path.relative(process.cwd(), file)}::${fullTitle}`;
  }

  _guessMime(name = '') {
    const n = (name || '').toLowerCase();
    if (n.endsWith('.png')) return 'image/png';
    if (n.endsWith('.jpg') || n.endsWith('.jpeg')) return 'image/jpeg';
    if (n.endsWith('.webp')) return 'image/webp';
    if (n.endsWith('.html')) return 'text/html';
    if (n.endsWith('.txt') || n.endsWith('.log')) return 'text/plain';
    return 'application/octet-stream';
  }

  _renderHtml(report, history, lastReport) {
    const css = `
    body{font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:18px; background:#f4f6fb}
    .header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .title{font-size:20px;font-weight:700}
    .controls{display:flex;gap:8px;align-items:center}
    .search{padding:8px 10px;border-radius:8px;border:1px solid #e3e6ee;background:#fff}
    .chip{padding:6px 10px;border-radius:999px;background:#fff;border:1px solid #e7e9f1}
    .tests{margin-top:16px;display:grid;grid-template-columns:repeat(auto-fill,minmax(380px,1fr));gap:12px}
    .card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 4px 14px rgba(20,30,60,0.04)}
    .status-passed{color:#116530;font-weight:600}
    .status-failed{color:#a61e4d;font-weight:700}
    .status-skipped{color:#6b7280;font-weight:600}
    .meta{font-size:12px;color:#6b7280}
    .attachments img{max-width:100%;border-radius:6px;margin-top:8px}
    details summary{cursor:pointer}
    `;

    const escaped = (s) => {
      if (s === undefined || s === null) return '';
      return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };

    const payload = { report, history, lastReport };
    const payloadJson = JSON.stringify(payload).replace(/</g, '\\u003c');

    const html = `<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Playwright Custom Report (TS)</title>
<style>${css}</style>
</head>
<body>
  <div class="header">
    <div>
      <div class="title">Playwright Custom Report</div>
      <div class="meta">Start: ${escaped(report.summary.startTime)} • Duration: ${Math.round(report.summary.durationMs/1000)}s • Tests: ${report.summary.total} • Failed: ${report.summary.failed}</div>
    </div>
    <div class="controls">
      <input id="search" class="search" placeholder="Search tests... (title, file)" />
      <select id="statusFilter" class="chip">
        <option value="all">All</option>
        <option value="failed">Failed</option>
        <option value="passed">Passed</option>
        <option value="skipped">Skipped</option>
      </select>
      <select id="sortBy" class="chip">
        <option value="none">Sort</option>
        <option value="duration">Longest</option>
        <option value="failures">Most historical failures</option>
      </select>
      <button id="toggleCompare" class="chip">${lastReport ? 'Toggle Compare' : 'No last run'}</button>
    </div>
  </div>

  <div id="tests" class="tests"></div>

  <script>
    const payload = ${payloadJson};
    const report = payload.report;
    const history = payload.history || {};
    const lastReport = payload.lastReport || null;

    function makeTestCard(t){
      const el = document.createElement('div'); el.className='card';
      const statusClass = t.status==='passed' ? 'status-passed' : t.status==='failed' ? 'status-failed' : 'status-skipped';
      const failures = history[t.id] || 0;

      let compareHtml = '';
      if (lastReport){
        const last = (lastReport.tests || []).find(x => x.id === t.id);
        if (last){
          if (last.status !== t.status){
            compareHtml = `<div class="meta">Compared to last run: <strong>${escapeHtml(last.status)}</strong></div>`;
          } else {
            compareHtml = `<div class="meta">Status unchanged vs last run</div>`;
          }
        }
      }

      el.innerHTML = \`
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="flex:1">
            <div style="font-weight:700">\${escapeHtml(t.fullTitle)}</div>
            <div class="meta">\${escapeHtml(t.file||'')} • \${t.durationMs? t.durationMs+'ms':''}</div>
          </div>
          <div style="margin-left:12px;text-align:right">
            <div class="\${statusClass}">\${escapeHtml(t.status)}</div>
            <div class="meta">Historical failures: <strong>\${failures}</strong></div>
          </div>
        </div>
        \${t.error ? \`<details><summary style="color:#a61e4d">Error: \${escapeHtml(shorten(t.error,120))}</summary><pre>\${escapeHtml(t.error)}</pre></details>\` : ''}
        \${t.attachments && t.attachments.length ? \`<div class="attachments">\${t.attachments.map(a=> a.dataUri ? \`<a href="\${a.dataUri}" target="_blank"><img src="\${a.dataUri}"/></a>\` : a.path? \`<a href="./\${encodeURI(a.path)}" target="_blank">\${escapeHtml(a.name||a.path)}</a>\`:escapeHtml(a.name)).join(' ')}</div>\` : ''}
      \`;
      return el;
    }

    function escapeHtml(s){ if(s==null) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    function shorten(s,n){ if(!s) return ''; return s.length>n? s.slice(0,n)+'…':s; }

    const container = document.getElementById('tests');
    const search = document.getElementById('search');
    const statusFilter = document.getElementById('statusFilter');
    const sortBy = document.getElementById('sortBy');
    const toggleCompare = document.getElementById('toggleCompare');
    let showCompare = !!lastReport;

    function render(){
      container.innerHTML = '';
      let tests = (report.tests || []).slice();
      const q = (search.value||'').toLowerCase().trim();
      const status = statusFilter.value;
      if (q){ tests = tests.filter(t => (t.fullTitle||'').toLowerCase().includes(q) || (t.file||'').toLowerCase().includes(q)); }
      if (status && status !== 'all') tests = tests.filter(t => t.status === status);

      const sort = sortBy.value;
      if (sort === 'duration') tests.sort((a,b)=> (b.durationMs||0) - (a.durationMs||0));
      else if (sort === 'failures') tests.sort((a,b)=> (history[b.id]||0) - (history[a.id]||0));

      for (const t of tests){
        const card = makeTestCard(t);
        container.appendChild(card);
      }
    }

    search.addEventListener('input', render);
    statusFilter.addEventListener('change', render);
    sortBy.addEventListener('change', render);
    toggleCompare.addEventListener('click', ()=>{ showCompare = !showCompare; alert('Compare toggled (note: UI currently highlights changes vs last run if present)'); });

    render();
  </script>
</body>
</html>`;

    return html;
  }
}

module.exports = CustomTsReporter;
