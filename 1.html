# Copilot Playwright Refactor — Minimal Instructions (Grouped Assertions)

## Goals (for Copilot to follow)
- Replace attribute-based selectors (e.g. `[data-id="..."]`, `[data-test-id="..."]`, `[data-testid="..."]`) with Playwright semantic locators where possible (`getByRole`, `getByLabel`, `getByPlaceholder`, `getByText`).
- Convert attribute selectors used via `page.locator(...)`, `locator(...)`, `page.fill(...)`, `page.click(...)`, and chained locator usages into semantic locators or `chooseLocator` fallbacks.
- Extract Page Objects into `/pages/<PageName>.ts` with `constructor(page: Page)` and action methods (e.g., `goto()`, `login()`).
- Extract UI verification logic from recorded `expect(...)` calls into Page Object assertion helpers.
- If multiple expect classes validate different UI pieces on the same page, group those validations into a single, composable POM method that accepts a structured parameter describing the checks to run.
- Do not add fixed waits. Rely on Playwright auto-waiting.

---

## Files to generate
```
/utilities/locatorHelper.ts
/pages/<PageName>.ts
/tests/<refactored>.spec.ts
```

---

## chooseLocator helper (must be generated exactly)
```ts
// /utilities/locatorHelper.ts
import type { Page, Locator } from '@playwright/test';

export function chooseLocator(page: Page, hints: {
  role?: { role: string, name?: string | RegExp },
  label?: string,
  placeholder?: string,
  text?: string | RegExp,
}, fallbackSelector: string): Locator {
  if (hints.role) {
    try {
      return page.getByRole(hints.role.role as any, hints.role.name ? { name: hints.role.name as any } : undefined);
    } catch {}
  }
  if (hints.label) return page.getByLabel(hints.label);
  if (hints.placeholder) return page.getByPlaceholder(hints.placeholder);
  if (hints.text) return page.getByText(hints.text as any);
  return page.locator(fallbackSelector);
}
```

---

## Grouped assertion method pattern
When several expect-classes target the same page, Copilot should create a single grouped assertion method on the Page Object with a signature like:

```ts
type Check = {
  name: string;                 // logical name of the check (e.g., 'welcome', 'errorBanner')
  locatorHints?: any;           // optional hints for chooseLocator if needed
  expected?: string | RegExp;   // expected text or regex
  present?: boolean;            // whether element should exist/be visible
  contains?: string | RegExp;   // alias for expected; can be used for partial matches
  count?: number;               // expected count of matching elements
  custom?: (page: Page) => Promise<boolean>; // optional ad-hoc check
};

async verifyManyChecks(checks: Check[]): Promise<void> { /* ... */ }
```

Implementation guidance for Copilot:
- For each `Check` in `checks`, prefer semantic locators constructed from `locatorHints` or infer from recorded text. Fall back to the original recorded selector using `chooseLocator`.
- Use Playwright `expect(locator).toHaveText(...)`, `expect(locator).toBeVisible()`, `expect(locator).toHaveCount(...)` as appropriate. `expect` assertions should be inside POM helper methods.
- Support `custom` for edge-cases — call it with `await check.custom(this.page)` and assert its boolean result.
- Keep the method deterministic and quick; if a particular check is expensive or flaky, mark it optional via `present?: false` or handle with retries in POM only if necessary.

---

## Example (Before -> After)
**Before (many expect classes used in a test):**
```ts
// recorded test
ExpectA.validateWelcome(page);
ExpectB.validateBanner(page);
ExpectC.validateUserInfo(page);
ExpectD.validateFooter(page);
```

**After (single grouped POM method):**
```ts
// pages/DashboardPage.ts (excerpt)
type Check = { name: string; expected?: string | RegExp; present?: boolean; };

export default class DashboardPage {
  // locators declared in constructor using chooseLocator or getByRole/getByLabel
  async verifyManyChecks(checks: Check[]) {
    for (const c of checks) {
      const locator = /* infer or use chooseLocator for c.name or c.locatorHints */;
      if (c.expected) {
        await expect(locator).toHaveText(new RegExp(String(c.expected), 'i'));
      } else if (c.present === false) {
        await expect(locator).toHaveCount(0);
      } else {
        await expect(locator).toBeVisible();
      }
    }
  }
}
```

**Test usage:**
```ts
await dashboardPage.verifyManyChecks([
  { name: 'welcome', expected: 'Welcome, Alice' },
  { name: 'banner', present: true },
  { name: 'userinfo', expected: /Alice/ },
]);
```

---

## Guidance for Copilot when grouping
- Map expect-class names to check `name` values and to locators in the POM (e.g., `expectWelcome` → `welcome` locator).
- If recorded expect-class methods include different locators, combine those locators into the POM and reference them inside `verifyManyChecks` by `name` or `locatorHints`.
- Keep `verifyManyChecks` flexible: accept regex/string for expected text, presence flags, count checks, and custom callbacks.
- Favor readability: tests should pass concise arrays of checks instead of calling many expect-classes.

---

## Final prompt to send to Copilot
```
Refactor the recorded test below according to the rules in the instructions above.
Convert attribute selectors to semantic locators or chooseLocator fallbacks.
Extract expect(...) logic into POM assertion helpers. If multiple expect-classes validate the same page, group them into a single POM method verifyManyChecks(checks: Check[]).
Create and save files directly in the repo: /utilities/locatorHelper.ts, /pages/<PageName>.ts, /tests/<refactored>.spec.ts
Use TypeScript and @playwright/test. Do not introduce fixed waits.
```

---

End of file.
