import path from "path";
import fs from "fs";
import ExcelJS from "exceljs";

export type Row = Record<string, string>;

type LoadOptions = {
  filePath: string;              // e.g. data/TestData.xlsx
  sheetName?: string;            // optional; first sheet if omitted
  yesValues?: string[];          // which values mean "run"
  trimHeaders?: boolean;         // default true
  normalizeHeaders?: boolean;    // default false (preserve Excel headers)
};

/** Convert any ExcelJS cell value to a string (empty when nullish). */
function toStringValue(v: unknown): string {
  if (v == null) return "";
  if (typeof v === "object" && "text" in (v as any)) return String((v as any).text ?? "").trim();
  return String(v).trim();
}

/** Optionally normalize header names (if you prefer stable keys). */
function normalize(h: string): string {
  return h.toLowerCase().replace(/\s+|[_-]+/g, "").trim();
}

export async function loadEnabledRows(opts: LoadOptions): Promise<Row[]> {
  const {
    filePath,
    sheetName,
    yesValues = ["yes", "y", "true", "1"],
    trimHeaders = true,
    normalizeHeaders = false,
  } = opts;

  const workbook = new ExcelJS.Workbook();
  await workbook.xlsx.readFile(path.resolve(filePath));

  const sheet = sheetName ? workbook.getWorksheet(sheetName) : workbook.worksheets[0];
  if (!sheet) throw new Error(`Worksheet "${sheetName ?? "<first>"}" not found`);

  // 1) Read headers from row 1
  const headersRaw: string[] = [];
  sheet.getRow(1).eachCell((cell, col) => {
    const raw = String(cell.value ?? "");
    headersRaw[col - 1] = trimHeaders ? raw.trim() : raw;
  });

  const headers = headersRaw.map(h => (normalizeHeaders ? normalize(h) : h));

  const enabled: Row[] = [];

  // 2) Iterate rows
  sheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
    if (rowNumber === 1) return; // skip header

    const obj: Row = {};
    // Fill with empty strings by default for ALL headers
    for (const h of headers) obj[h] = "";

    headers.forEach((h, idx) => {
      const v = row.getCell(idx + 1).value;
      obj[h] = toStringValue(v);
    });

    // Default RunMode = "No" if absent/blank
    const runModeKey = headers.find(h => h.toLowerCase() === "runmode");
    const run = toStringValue(runModeKey ? obj[runModeKey] : "").toLowerCase() || "no";
    if (runModeKey) obj[runModeKey] = run; // keep what we computed

    if (yesValues.includes(run)) {
      enabled.push(obj);
    }
  });

  return enabled;
}

export function writeRowsJson(rows: Row[], outPath: string) {
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, JSON.stringify(rows, null, 2), "utf8");
}
